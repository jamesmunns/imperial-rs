#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const NULL: u32 = 0;
pub const NORTH: u32 = 0;
pub const NORTHEAST: u32 = 1;
pub const EAST: u32 = 2;
pub const SOUTHEAST: u32 = 3;
pub const SOUTH: u32 = 4;
pub const SOUTHWEST: u32 = 5;
pub const WEST: u32 = 6;
pub const NORTHWEST: u32 = 7;
pub const NUMTOPS: u32 = 3;
pub const NUMSIDES: u32 = 6;
pub const STRSIZE: u32 = 400;
pub const UNOWNED: u32 = 0;
pub const USER: u32 = 1;
pub const COMP: u32 = 2;
pub const ARMY: u32 = 0;
pub const FIGHTER: u32 = 1;
pub const PATROL: u32 = 2;
pub const DESTROYER: u32 = 3;
pub const SUBMARINE: u32 = 4;
pub const TRANSPORT: u32 = 5;
pub const CARRIER: u32 = 6;
pub const BATTLESHIP: u32 = 7;
pub const SATELLITE: u32 = 8;
pub const NUM_OBJECTS: u32 = 9;
pub const LIST_SIZE: u32 = 5000;
pub const NOFUNC: i32 = -1;
pub const RANDOM: i32 = -2;
pub const SENTRY: i32 = -3;
pub const FILL: i32 = -4;
pub const LAND: i32 = -5;
pub const EXPLORE: i32 = -6;
pub const ARMYLOAD: i32 = -7;
pub const ARMYATTACK: i32 = -8;
pub const TTLOAD: i32 = -9;
pub const REPAIR: i32 = -10;
pub const WFTRANSPORT: i32 = -11;
pub const MOVE_N: i32 = -12;
pub const MOVE_NE: i32 = -13;
pub const MOVE_E: i32 = -14;
pub const MOVE_SE: i32 = -15;
pub const MOVE_S: i32 = -16;
pub const MOVE_SW: i32 = -17;
pub const MOVE_W: i32 = -18;
pub const MOVE_NW: i32 = -19;
pub const INFINITY: u32 = 10000000;
pub const MAP_WIDTH: u32 = 100;
pub const MAP_HEIGHT: u32 = 60;
pub const MAP_SIZE: u32 = 6000;
pub const NUM_CITY: u32 = 70;
pub const T_UNKNOWN: u32 = 0;
pub const T_PATH: u32 = 1;
pub const T_LAND: u32 = 2;
pub const T_WATER: u32 = 4;
pub const T_AIR: u32 = 6;
pub const SECTOR_ROWS: u32 = 5;
pub const SECTOR_COLS: u32 = 2;
pub const NUM_SECTORS: u32 = 10;
pub const ROWS_PER_SECTOR: u32 = 12;
pub const COLS_PER_SECTOR: u32 = 50;
pub const W_TT_BUILD: i32 = -1;
pub const MAP_LAND: u8 = 43u8;
pub const MAP_SEA: u8 = 46u8;
pub const MAP_CITY: u8 = 42u8;
pub type uchar = ::libc::c_uchar;
pub type loc_t = ::libc::c_long;
pub type count_t = ::libc::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct city_info {
    pub loc: loc_t,
    pub owner: uchar,
    pub func: [::libc::c_long; 9usize],
    pub work: ::libc::c_long,
    pub prod: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_city_info() {
    assert_eq!(
        ::core::mem::size_of::<city_info>(),
        104usize,
        concat!("Size of: ", stringify!(city_info))
    );
    assert_eq!(
        ::core::mem::align_of::<city_info>(),
        8usize,
        concat!("Alignment of ", stringify!(city_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<city_info>())).loc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(city_info),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<city_info>())).owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(city_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<city_info>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(city_info),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<city_info>())).work as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(city_info),
            "::",
            stringify!(work)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<city_info>())).prod as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(city_info),
            "::",
            stringify!(prod)
        )
    );
}
pub type city_info_t = city_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct link_t {
    pub next: *mut piece_info,
    pub prev: *mut piece_info,
}
#[test]
fn bindgen_test_layout_link_t() {
    assert_eq!(
        ::core::mem::size_of::<link_t>(),
        16usize,
        concat!("Size of: ", stringify!(link_t))
    );
    assert_eq!(
        ::core::mem::align_of::<link_t>(),
        8usize,
        concat!("Alignment of ", stringify!(link_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<link_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(link_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<link_t>())).prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(link_t),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct piece_info {
    pub piece_link: link_t,
    pub loc_link: link_t,
    pub cargo_link: link_t,
    pub owner: ::libc::c_int,
    pub type_: ::libc::c_int,
    pub loc: loc_t,
    pub func: ::libc::c_long,
    pub hits: ::libc::c_short,
    pub moved: ::libc::c_int,
    pub ship: *mut piece_info,
    pub cargo: *mut piece_info,
    pub count: ::libc::c_short,
    pub range: ::libc::c_short,
}
#[test]
fn bindgen_test_layout_piece_info() {
    assert_eq!(
        ::core::mem::size_of::<piece_info>(),
        104usize,
        concat!("Size of: ", stringify!(piece_info))
    );
    assert_eq!(
        ::core::mem::align_of::<piece_info>(),
        8usize,
        concat!("Alignment of ", stringify!(piece_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).piece_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(piece_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).loc_link as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(loc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).cargo_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(cargo_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).owner as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).type_ as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).loc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).func as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).hits as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).moved as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(moved)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).ship as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(ship)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).cargo as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(cargo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).count as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_info>())).range as *const _ as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_info),
            "::",
            stringify!(range)
        )
    );
}
pub type piece_info_t = piece_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct piece_attr {
    pub sname: ::libc::c_char,
    pub name: [::libc::c_char; 20usize],
    pub nickname: [::libc::c_char; 20usize],
    pub article: [::libc::c_char; 20usize],
    pub plural: [::libc::c_char; 20usize],
    pub terrain: [::libc::c_char; 4usize],
    pub build_time: uchar,
    pub strength: uchar,
    pub max_hits: uchar,
    pub speed: uchar,
    pub capacity: uchar,
    pub range: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_piece_attr() {
    assert_eq!(
        ::core::mem::size_of::<piece_attr>(),
        104usize,
        concat!("Size of: ", stringify!(piece_attr))
    );
    assert_eq!(
        ::core::mem::align_of::<piece_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(piece_attr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).sname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(sname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).name as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).nickname as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(nickname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).article as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(article)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).plural as *const _ as usize },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(plural)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).terrain as *const _ as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(terrain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).build_time as *const _ as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(build_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).strength as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(strength)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).max_hits as *const _ as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(max_hits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).speed as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).capacity as *const _ as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<piece_attr>())).range as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(piece_attr),
            "::",
            stringify!(range)
        )
    );
}
pub type piece_attr_t = piece_attr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct real_map {
    pub contents: ::libc::c_char,
    pub on_board: bool,
    pub cityp: *mut city_info_t,
    pub objp: *mut piece_info_t,
}
#[test]
fn bindgen_test_layout_real_map() {
    assert_eq!(
        ::core::mem::size_of::<real_map>(),
        24usize,
        concat!("Size of: ", stringify!(real_map))
    );
    assert_eq!(
        ::core::mem::align_of::<real_map>(),
        8usize,
        concat!("Alignment of ", stringify!(real_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<real_map>())).contents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(real_map),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<real_map>())).on_board as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(real_map),
            "::",
            stringify!(on_board)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<real_map>())).cityp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(real_map),
            "::",
            stringify!(cityp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<real_map>())).objp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(real_map),
            "::",
            stringify!(objp)
        )
    );
}
pub type real_map_t = real_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct view_map {
    pub contents: ::libc::c_char,
    pub seen: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_view_map() {
    assert_eq!(
        ::core::mem::size_of::<view_map>(),
        16usize,
        concat!("Size of: ", stringify!(view_map))
    );
    assert_eq!(
        ::core::mem::align_of::<view_map>(),
        8usize,
        concat!("Alignment of ", stringify!(view_map))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<view_map>())).contents as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(view_map),
            "::",
            stringify!(contents)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<view_map>())).seen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(view_map),
            "::",
            stringify!(seen)
        )
    );
}
pub type view_map_t = view_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct path_map_t {
    pub cost: ::libc::c_int,
    pub inc_cost: ::libc::c_int,
    pub terrain: ::libc::c_char,
}
#[test]
fn bindgen_test_layout_path_map_t() {
    assert_eq!(
        ::core::mem::size_of::<path_map_t>(),
        12usize,
        concat!("Size of: ", stringify!(path_map_t))
    );
    assert_eq!(
        ::core::mem::align_of::<path_map_t>(),
        4usize,
        concat!("Alignment of ", stringify!(path_map_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path_map_t>())).cost as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(path_map_t),
            "::",
            stringify!(cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path_map_t>())).inc_cost as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(path_map_t),
            "::",
            stringify!(inc_cost)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<path_map_t>())).terrain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(path_map_t),
            "::",
            stringify!(terrain)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct scan_counts_t {
    pub user_cities: ::libc::c_int,
    pub user_objects: [::libc::c_int; 9usize],
    pub comp_cities: ::libc::c_int,
    pub comp_objects: [::libc::c_int; 9usize],
    pub size: ::libc::c_int,
    pub unowned_cities: ::libc::c_int,
    pub unexplored: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_scan_counts_t() {
    assert_eq!(
        ::core::mem::size_of::<scan_counts_t>(),
        92usize,
        concat!("Size of: ", stringify!(scan_counts_t))
    );
    assert_eq!(
        ::core::mem::align_of::<scan_counts_t>(),
        4usize,
        concat!("Alignment of ", stringify!(scan_counts_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).user_cities as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(user_cities)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).user_objects as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(user_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).comp_cities as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(comp_cities)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).comp_objects as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(comp_objects)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).unowned_cities as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(unowned_cities)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<scan_counts_t>())).unexplored as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(scan_counts_t),
            "::",
            stringify!(unexplored)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct move_info_t {
    pub city_owner: ::libc::c_char,
    pub objectives: *mut ::libc::c_char,
    pub weights: [::libc::c_int; 11usize],
}
#[test]
fn bindgen_test_layout_move_info_t() {
    assert_eq!(
        ::core::mem::size_of::<move_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(move_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<move_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(move_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<move_info_t>())).city_owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(move_info_t),
            "::",
            stringify!(city_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<move_info_t>())).objectives as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(move_info_t),
            "::",
            stringify!(objectives)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<move_info_t>())).weights as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(move_info_t),
            "::",
            stringify!(weights)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perimeter_t {
    pub len: ::libc::c_long,
    pub list: [::libc::c_long; 6000usize],
}
#[test]
fn bindgen_test_layout_perimeter_t() {
    assert_eq!(
        ::core::mem::size_of::<perimeter_t>(),
        48008usize,
        concat!("Size of: ", stringify!(perimeter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<perimeter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(perimeter_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<perimeter_t>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(perimeter_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<perimeter_t>())).list as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(perimeter_t),
            "::",
            stringify!(list)
        )
    );
}
pub const win_t_no_win: win_t = 0;
pub const win_t_wipeout_win: win_t = 1;
pub const win_t_ratio_win: win_t = 2;
pub type win_t = u32;
extern "C" {
    #[link_name = "\u{1}SMOOTH"]
    pub static mut SMOOTH: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}WATER_RATIO"]
    pub static mut WATER_RATIO: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}MIN_CITY_DIST"]
    pub static mut MIN_CITY_DIST: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}delay_time"]
    pub static mut delay_time: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}save_interval"]
    pub static mut save_interval: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}map"]
    pub static mut map: [real_map_t; 6000usize];
}
extern "C" {
    #[link_name = "\u{1}comp_map"]
    pub static mut comp_map: [view_map_t; 6000usize];
}
extern "C" {
    #[link_name = "\u{1}user_map"]
    pub static mut user_map: [view_map_t; 6000usize];
}
extern "C" {
    #[link_name = "\u{1}city"]
    pub static mut city: [city_info_t; 70usize];
}
extern "C" {
    #[link_name = "\u{1}free_list"]
    pub static mut free_list: *mut piece_info_t;
}
extern "C" {
    #[link_name = "\u{1}user_obj"]
    pub static mut user_obj: [*mut piece_info_t; 9usize];
}
extern "C" {
    #[link_name = "\u{1}comp_obj"]
    pub static mut comp_obj: [*mut piece_info_t; 9usize];
}
extern "C" {
    #[link_name = "\u{1}object"]
    pub static mut object: [piece_info_t; 5000usize];
}
extern "C" {
    #[link_name = "\u{1}lines"]
    pub static mut lines: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}cols"]
    pub static mut cols: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}piece_attr"]
    pub static mut piece_attr: [piece_attr_t; 0usize];
}
extern "C" {
    #[link_name = "\u{1}dir_offset"]
    pub static mut dir_offset: [::libc::c_int; 0usize];
}
extern "C" {
    #[link_name = "\u{1}func_name"]
    pub static mut func_name: [*mut ::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}move_order"]
    pub static mut move_order: [::libc::c_int; 0usize];
}
extern "C" {
    #[link_name = "\u{1}type_chars"]
    pub static mut type_chars: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}tt_attack"]
    pub static mut tt_attack: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}army_attack"]
    pub static mut army_attack: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}fighter_attack"]
    pub static mut fighter_attack: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}ship_attack"]
    pub static mut ship_attack: [::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}tt_load"]
    pub static mut tt_load: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}tt_explore"]
    pub static mut tt_explore: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}tt_unload"]
    pub static mut tt_unload: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}army_fight"]
    pub static mut army_fight: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}army_load"]
    pub static mut army_load: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}fighter_fight"]
    pub static mut fighter_fight: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}ship_fight"]
    pub static mut ship_fight: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}ship_repair"]
    pub static mut ship_repair: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}user_army"]
    pub static mut user_army: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}user_army_attack"]
    pub static mut user_army_attack: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}user_fighter"]
    pub static mut user_fighter: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}user_ship"]
    pub static mut user_ship: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}user_ship_repair"]
    pub static mut user_ship_repair: move_info_t;
}
extern "C" {
    #[link_name = "\u{1}help_cmd"]
    pub static mut help_cmd: [*mut ::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}help_edit"]
    pub static mut help_edit: [*mut ::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}help_user"]
    pub static mut help_user: [*mut ::libc::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}cmd_lines"]
    pub static mut cmd_lines: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}edit_lines"]
    pub static mut edit_lines: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}user_lines"]
    pub static mut user_lines: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}date"]
    pub static mut date: ::libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}automove"]
    pub static mut automove: bool;
}
extern "C" {
    #[link_name = "\u{1}resigned"]
    pub static mut resigned: bool;
}
extern "C" {
    #[link_name = "\u{1}debug"]
    pub static mut debug: bool;
}
extern "C" {
    #[link_name = "\u{1}print_debug"]
    pub static mut print_debug: bool;
}
extern "C" {
    #[link_name = "\u{1}print_vmap"]
    pub static mut print_vmap: ::libc::c_char;
}
extern "C" {
    #[link_name = "\u{1}trace_pmap"]
    pub static mut trace_pmap: bool;
}
extern "C" {
    #[link_name = "\u{1}win"]
    pub static mut win: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}jnkbuf"]
    pub static mut jnkbuf: [::libc::c_char; 400usize];
}
extern "C" {
    #[link_name = "\u{1}save_movie"]
    pub static mut save_movie: bool;
}
extern "C" {
    #[link_name = "\u{1}user_score"]
    pub static mut user_score: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}comp_score"]
    pub static mut comp_score: ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}savefile"]
    pub static mut savefile: *mut ::libc::c_char;
}
extern "C" {
    pub fn empire();
}
extern "C" {
    pub fn attack(att_obj: *mut piece_info_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn comp_move(nmoves: ::libc::c_int);
}
extern "C" {
    pub fn user_move();
}
extern "C" {
    pub fn edit(edit_cursor: ::libc::c_long);
}
extern "C" {
    pub fn vmap_cont(
        cont_map: *mut ::libc::c_int,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        bad_terrain: ::libc::c_char,
    );
}
extern "C" {
    pub fn rmap_cont(
        cont_map: *mut ::libc::c_int,
        loc: ::libc::c_long,
        bad_terrain: ::libc::c_char,
    );
}
extern "C" {
    pub fn vmap_mark_up_cont(
        cont_map: *mut ::libc::c_int,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        bad_terrain: ::libc::c_char,
    );
}
extern "C" {
    pub fn vmap_cont_scan(cont_map: *mut ::libc::c_int, vmap: *mut view_map_t) -> scan_counts_t;
}
extern "C" {
    pub fn rmap_cont_scan(cont_map: *mut ::libc::c_int) -> scan_counts_t;
}
extern "C" {
    pub fn map_cont_edge(cont_map: *mut ::libc::c_int, loc: ::libc::c_long) -> bool;
}
extern "C" {
    pub fn vmap_find_aobj(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        move_info: *mut move_info_t,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_find_wobj(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        move_info: *mut move_info_t,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_find_lobj(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        move_info: *mut move_info_t,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_find_lwobj(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        move_info: *mut move_info_t,
        beat_cost: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_find_wlobj(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        move_info: *mut move_info_t,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_find_dest(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        cur_loc: ::libc::c_long,
        dest_loc: ::libc::c_long,
        owner: ::libc::c_int,
        terrain: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_prune_explore_locs(vmap: *mut view_map_t);
}
extern "C" {
    pub fn vmap_mark_path(path_map: *mut path_map_t, vmap: *mut view_map_t, dest: ::libc::c_long);
}
extern "C" {
    pub fn vmap_mark_adjacent(path_map: *mut path_map_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn vmap_mark_near_path(path_map: *mut path_map_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn vmap_find_dir(
        path_map: *mut path_map_t,
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        terrain: *mut ::libc::c_char,
        adjchar: *mut ::libc::c_char,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn vmap_count_adjacent(
        vmap: *mut view_map_t,
        loc: ::libc::c_long,
        adj_char: *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn vmap_shore(vmap: *mut view_map_t, loc: ::libc::c_long) -> bool;
}
extern "C" {
    pub fn rmap_shore(loc: ::libc::c_long) -> bool;
}
extern "C" {
    pub fn vmap_at_sea(vmap: *mut view_map_t, loc: ::libc::c_long) -> bool;
}
extern "C" {
    pub fn rmap_at_sea(loc: ::libc::c_long) -> bool;
}
extern "C" {
    pub fn announce(arg1: *mut ::libc::c_char);
}
extern "C" {
    pub fn redisplay();
}
extern "C" {
    pub fn kill_display();
}
extern "C" {
    pub fn sector_change();
}
extern "C" {
    pub fn cur_sector() -> ::libc::c_int;
}
extern "C" {
    pub fn cur_cursor() -> ::libc::c_long;
}
extern "C" {
    pub fn display_loc(whose: ::libc::c_int, vmap: *mut view_map_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn display_locx(whose: ::libc::c_int, vmap: *mut view_map_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn print_sector(whose: ::libc::c_int, vmap: *mut view_map_t, sector: ::libc::c_int);
}
extern "C" {
    pub fn move_cursor(cursor: *mut ::libc::c_long, offset: ::libc::c_int) -> bool;
}
extern "C" {
    pub fn print_zoom(vmap: *mut view_map_t);
}
extern "C" {
    pub fn print_pzoom(s: *mut ::libc::c_char, pmap: *mut path_map_t, vmap: *mut view_map_t);
}
extern "C" {
    pub fn print_xzoom(vmap: *mut view_map_t);
}
extern "C" {
    pub fn display_score();
}
extern "C" {
    pub fn redraw();
}
extern "C" {
    pub fn clear_screen();
}
extern "C" {
    pub fn complain();
}
extern "C" {
    pub fn delay();
}
extern "C" {
    pub fn close_disp();
}
extern "C" {
    pub fn pos_str(row: ::libc::c_int, col: ::libc::c_int, str: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn direction() -> ::libc::c_int;
}
extern "C" {
    pub fn init_game();
}
extern "C" {
    pub fn save_game();
}
extern "C" {
    pub fn restore_game() -> ::libc::c_int;
}
extern "C" {
    pub fn save_movie_screen();
}
extern "C" {
    pub fn replay_movie();
}
extern "C" {
    pub fn get_str(buf: *mut ::libc::c_char, sizep: ::libc::c_int);
}
extern "C" {
    pub fn get_strq(buf: *mut ::libc::c_char, sizep: ::libc::c_int);
}
extern "C" {
    pub fn get_chx() -> ::libc::c_char;
}
extern "C" {
    pub fn getint(message: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn get_c() -> ::libc::c_char;
}
extern "C" {
    pub fn get_cq() -> ::libc::c_char;
}
extern "C" {
    pub fn getyn(message: *mut ::libc::c_char) -> bool;
}
extern "C" {
    pub fn get_range(
        message: *mut ::libc::c_char,
        low: ::libc::c_int,
        high: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn rndini();
}
extern "C" {
    pub fn irand(high: ::libc::c_long) -> ::libc::c_long;
}
extern "C" {
    pub fn dist(a: ::libc::c_long, b: ::libc::c_long) -> ::libc::c_int;
}
extern "C" {
    pub fn isqrt(n: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn find_nearest_city(
        loc: ::libc::c_long,
        owner: ::libc::c_int,
        city_loc: *mut ::libc::c_long,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn find_city(loc: ::libc::c_long) -> *mut city_info_t;
}
extern "C" {
    pub fn find_obj(type_: ::libc::c_int, loc: ::libc::c_long) -> *mut piece_info_t;
}
extern "C" {
    pub fn find_nfull(type_: ::libc::c_int, loc: ::libc::c_long) -> *mut piece_info_t;
}
extern "C" {
    pub fn find_transport(owner: ::libc::c_int, loc: ::libc::c_long) -> ::libc::c_long;
}
extern "C" {
    pub fn find_obj_at_loc(loc: ::libc::c_long) -> *mut piece_info_t;
}
extern "C" {
    pub fn obj_moves(obj: *mut piece_info_t) -> ::libc::c_int;
}
extern "C" {
    pub fn obj_capacity(obj: *mut piece_info_t) -> ::libc::c_int;
}
extern "C" {
    pub fn kill_obj(obj: *mut piece_info_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn kill_city(cityp: *mut city_info_t);
}
extern "C" {
    pub fn produce(cityp: *mut city_info_t);
}
extern "C" {
    pub fn move_obj(obj: *mut piece_info_t, new_loc: ::libc::c_long);
}
extern "C" {
    pub fn move_sat(obj: *mut piece_info_t);
}
extern "C" {
    pub fn good_loc(obj: *mut piece_info_t, loc: ::libc::c_long) -> bool;
}
extern "C" {
    pub fn embark(ship: *mut piece_info_t, obj: *mut piece_info_t);
}
extern "C" {
    pub fn disembark(obj: *mut piece_info_t);
}
extern "C" {
    pub fn describe_obj(obj: *mut piece_info_t);
}
extern "C" {
    pub fn scan(vmap: *mut view_map_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn scan_sat(vmap: *mut view_map_t, loc: ::libc::c_long);
}
extern "C" {
    pub fn set_prod(cityp: *mut city_info_t);
}
extern "C" {
    pub fn pdebug(s: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn topini();
}
extern "C" {
    pub fn clreol(line: ::libc::c_int, colp: ::libc::c_int);
}
extern "C" {
    pub fn topmsg(line: ::libc::c_int, fmt: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn prompt(fmt: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn error(fmt: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn info(a: *mut ::libc::c_char, b: *mut ::libc::c_char, c: *mut ::libc::c_char);
}
extern "C" {
    pub fn comment(fmt: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn extra(fmt: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn huh();
}
extern "C" {
    pub fn help(text: *mut *mut ::libc::c_char, nlines: ::libc::c_int);
}
extern "C" {
    pub fn set_need_delay();
}
extern "C" {
    pub fn ksend(fmt: *mut ::libc::c_char, ...);
}
extern "C" {
    pub fn ttinit();
}
extern "C" {
    pub fn assert(expression: *mut ::libc::c_char, file: *mut ::libc::c_char, line: ::libc::c_int);
}
extern "C" {
    pub fn empend();
}
extern "C" {
    pub fn upper(c: ::libc::c_char) -> ::libc::c_char;
}
extern "C" {
    pub fn tupper(str: *mut ::libc::c_char);
}
extern "C" {
    pub fn check();
}
extern "C" {
    pub fn loc_disp(loc: ::libc::c_int) -> ::libc::c_int;
}
